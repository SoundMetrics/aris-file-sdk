// Copyright 2015-2018 Sound Metrics Corp. All Rights Reserved.

using System;

namespace SoundMetrics.Aris.Files
{
    using static ArgChecks;

    // These are available in a user-friendly static class. ("using static MatchResult.")

    /// <summary>
    /// Easily accessed helpers for matching Result types.
    /// Use "using static MatchResult;".
    /// </summary>
    public static class MatchResult
    {
        /// <summary>
        /// Easily accessible alias for Result.Match. This form does not return a value.
        /// </summary>
        public static void Match<T, TError>(
            Result<T, TError> result, Action<T> onOk, Action<TError> onError) =>
                Result<T, TError>.Match(result, onOk, onError);

        /// <summary>
        /// Easily accessible alias for Result.Match. This form returns a value.
        /// </summary>
        public static TResult Match<T, TError, TResult>(
            Result<T, TError> result, Func<T, TResult> onOk, Func<TError, TResult> onError) =>
                Result<T, TError>.Match(result, onOk, onError);
    }

    /// <summary>
    /// The result type for handling compound return values. The Match functions are used
    /// to access the contents of this type: there is no possibility of accessing the incorrect
    /// part of the type, whether Ok or Error.
    /// </summary>
    /// <typeparam name="T">The value type when an Ok result.</typeparam>
    /// <typeparam name="TError">The value type when an Error result.</typeparam>
    public struct Result<T, TError>
    {
        /// <summary>
        /// Creates an Ok instance of Result.
        /// </summary>
        /// <param name="value">The value to be assigned.</param>
        /// <returns>A instance that can only be evaluated as Ok.</returns>
        public static Result<T, TError> Ok(T value) => new Result<T, TError>(value);

        /// <summary>
        /// Creates an Error instance of Result.
        /// </summary>
        /// <param name="error">The value to be assigned.</param>
        /// <returns>A instance that can only be evaluated as Error.</returns>
        public static Result<T, TError> Error(TError error) => new Result<T, TError>(error);

        /// <summary>
        /// Applies code based on whether the Result value is Ok or Error.
        /// The callback functions are provided with the value of the instance, and
        /// only one of the callback functions is called based on the value.
        /// See MatchResult.Match for an easily accessible alias.
        /// </summary>
        /// <param name="result">The Result instance to be examined.</param>
        /// <param name="onOk">The callback invoked when the result value is Ok.</param>
        /// <param name="onError">The callback invoked when the result value is Error.</param>
        public static void Match(
            Result<T, TError> result, Action<T> onOk, Action<TError> onError)
        {
            CheckNotNull(onOk, nameof(onOk));
            CheckNotNull(onError, nameof(onError));

            if (result._isError)
            {
                onError(result._error);
            }
            else
            {
                onOk(result._value);
            }
        }

        /// <summary>
        /// Applies code based on whether the Result value is Ok or Error.
        /// The callback functions are provided with the value of the instance, and
        /// only one of the callback functions is called based on the value.
        /// See MatchResult.Match for an easily accessible alias.
        /// </summary>
        /// <param name="result">The Result instance to be examined.</param>
        /// <param name="onOk">The callback invoked when the result value is Ok.</param>
        /// <param name="onError">The callback invoked when the result value is Error.</param>
        /// <returns>The value generated by onOk or onError.</returns>
        public static TResult Match<TResult>(
            Result<T, TError> result, Func<T, TResult> onOk, Func<TError, TResult> onError)
        {
            CheckNotNull(onOk, nameof(onOk));
            CheckNotNull(onError, nameof(onError));

            if (result._isError)
            {
                return onError(result._error);
            }
            else
            {
                return onOk(result._value);
            }
        }

        /// <summary>
        /// Provides monad-ish binding capability on Ok results.
        /// Note that on Error f is not called, but the return type
        /// is modified to use U.
        /// </summary>
        /// <typeparam name="U">The value to which the value is transformed.</typeparam>
        /// <param name="f">The function applied to transform the value.</param>
        /// <returns>The new Result instance.</returns>
        public Result<U, TError> Bind<U>(Func<T, Result<U, TError>> f)
        {
            if (_isError)
            {
                return Result<U, TError>.Error(_error);
            }
            else
            {
                return f(_value);
            }
        }

        private Result(T value)
        {
            _value = value;
            _error = default(TError);
            _isError = false;
        }

        private Result(TError error)
        {
            _value = default(T);
            _error = error;
            _isError = true;
        }

        private readonly bool _isError;
        private readonly T _value;
        private readonly TError _error;
    }
}
